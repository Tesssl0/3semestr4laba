#include "worker_processing.h"

// Функция generate_data: генерирует тестовый набор данных работников
// Параметры:
//   n - количество работников для генерации
// Возвращает:
//   вектор объектов Worker со случайными данными
vector<Worker> generate_data(size_t n) {
    vector<Worker> v;                // Вектор для хранения работников
    v.reserve(n);                   // Предварительное выделение памяти для оптимизации

    // Инициализация генератора случайных чисел
    // random_device{} обеспечивает случайное начальное значение (seed)
    mt19937 gen(random_device{}());

    // Распределения для генерации случайных значений:
    uniform_int_distribution<int> age_dist(20, 60);           // Возраст от 20 до 60 лет
    uniform_real_distribution<double> sal_dist(30000.0, 150000.0); // Зарплата от 30к до 150к

    // Список возможных должностей
    vector<string> positions = { "A", "B", "C", "D" };

    // Генерация n работников
    for (size_t i = 0; i < n; ++i) {
        Worker w;  // Создание нового объекта работника

        // Заполнение полей случайными данными:
        w.fio = "Worker_" + to_string(i);                     // Уникальный идентификатор
        w.position = positions[gen() % positions.size()];    // Случайная должность из списка
        w.age = age_dist(gen);                               // Случайный возраст
        w.salary = sal_dist(gen);                            // Случайная зарплата

        v.push_back(w);  // Добавление работника в вектор
    }
    return v;  // Возврат сгенерированного набора данных
}

// Функция process_single: однопоточная обработка данных
// Выполняет две задачи:
//   1. Вычисляет средний возраст работников с должностью D
//   2. Находит максимальную зарплату среди работников должности D, 
//      чей возраст отличается от среднего не более чем на 2 года
// Параметры:
//   v - вектор работников для обработки
//   D - искомая должность (в данном случае "D")
// Возвращает:
//   пару значений: средний возраст и максимальная зарплата
pair<double, double> process_single(const vector<Worker>& v, const string& D) {
    long long sum_age = 0;  // Сумма возрастов (long long для избежания переполнения)
    size_t cnt = 0;         // Количество работников с должностью D

    // ---------- Первый проход: вычисление среднего возраста ----------
    // Проходим по всем работникам и суммируем возраст тех, у кого должность D
    for (auto& w : v) {
        if (w.position == D) {
            sum_age += w.age;   // Добавляем возраст к общей сумме
            ++cnt;              // Увеличиваем счетчик
        }
    }

    // Вычисление среднего возраста с проверкой деления на ноль
    double avg_age = cnt ? static_cast<double>(sum_age) / cnt : 0.0;
    double max_salary = 0.0;  // Переменная для хранения максимальной зарплаты

    // ---------- Второй проход: поиск максимальной зарплаты ----------
    // Ищем максимальную зарплату среди работников, удовлетворяющих условиям:
    // 1. Должность равна D
    // 2. Возраст отличается от среднего не более чем на 2 года (по модулю)
    for (auto& w : v) {
        if (w.position == D && fabs(w.age - avg_age) <= 2.0) {
            if (w.salary > max_salary) {
                max_salary = w.salary;  // Обновляем максимальную зарплату
            }
        }
    }

    return { avg_age, max_salary };  // Возврат результатов
}

// Функция process_multi: многопоточная обработка данных
// Реализует параллельную обработку с использованием заданного количества потоков
// Использует двухфазный подход:
//   Фаза 1: параллельное вычисление среднего возраста
//   Фаза 2: параллельный поиск максимальной зарплаты
// Параметры:
//   v - вектор работников для обработки
//   D - искомая должность
//   thread_count - количество потоков для использования
// Возвращает:
//   пару значений: средний возраст и максимальная зарплата
pair<double, double> process_multi(const vector<Worker>& v, const string& D, int thread_count) {
    size_t n = v.size();  // Общее количество работников

    // Корректировка количества потоков, если их больше чем работников
    if (thread_count > (int)n) thread_count = (int)n;
    if (thread_count <= 0) thread_count = 1;  // Минимум 1 поток

    // ---------- Фаза 1: Вычисление среднего возраста ----------
    vector<thread> threads;                     // Вектор для хранения потоков
    threads.reserve(thread_count);              // Резервирование памяти

    // Векторы для хранения частичных результатов каждого потока:
    vector<long long> partial_sums(thread_count, 0);   // Частичные суммы возрастов
    vector<size_t> partial_counts(thread_count, 0);    // Частичные количества работников

    // Лямбда-функция для обработки фрагмента данных в отдельном потоке
    // Каждый поток обрабатывает свой сегмент массива
    auto worker_age = [&](int idx) {
        // Вычисление границ сегмента данных для текущего потока
        size_t begin = n * idx / thread_count;      // Начальная позиция
        size_t end = n * (idx + 1) / thread_count;  // Конечная позиция

        long long local_sum = 0;  // Локальная сумма возрастов
        size_t local_cnt = 0;     // Локальный счетчик работников

        // Обработка своего сегмента данных
        for (size_t i = begin; i < end; ++i) {
            if (v[i].position == D) {
                local_sum += v[i].age;   // Суммируем возраст
                ++local_cnt;             // Считаем количество
            }
        }

        // Сохранение локальных результатов в общие структуры данных
        partial_sums[idx] = local_sum;
        partial_counts[idx] = local_cnt;
        };

    // Запуск потоков для обработки данных
    for (int i = 0; i < thread_count; ++i) {
        threads.emplace_back(worker_age, i);  // Создание и запуск потока
    }

    // Ожидание завершения всех потоков первой фазы
    for (auto& th : threads) {
        th.join();  // Блокировка до завершения потока
    }

    // Сборка глобальных результатов из частичных результатов
    long long total_sum = 0;   // Общая сумма возрастов
    size_t total_cnt = 0;      // Общее количество работников

    for (int i = 0; i < thread_count; ++i) {
        total_sum += partial_sums[i];   // Суммируем частичные суммы
        total_cnt += partial_counts[i]; // Суммируем частичные количества
    }

    // Вычисление среднего возраста по всем потокам
    double avg_age = total_cnt ? static_cast<double>(total_sum) / total_cnt : 0.0;

    // ---------- Фаза 2: Поиск максимальной зарплаты ----------
    // Очищаем вектор потоков для повторного использования
    threads.clear();

    // Вектор для хранения частичных максимумов зарплат
    vector<double> partial_max(thread_count, 0.0);

    // Лямбда-функция для поиска максимальной зарплаты в сегменте данных
    auto worker_max = [&](int idx) {
        size_t begin = n * idx / thread_count;
        size_t end = n * (idx + 1) / thread_count;

        double local_max = 0.0;  // Локальный максимум зарплаты

        // Поиск максимальной зарплаты в своем сегменте с учетом условий:
        for (size_t i = begin; i < end; ++i) {
            const auto& w = v[i];
            if (w.position == D && fabs(w.age - avg_age) <= 2.0) {
                if (w.salary > local_max) {
                    local_max = w.salary;  // Обновление локального максимума
                }
            }
        }

        partial_max[idx] = local_max;  // Сохранение результата
        };

    // Запуск потоков для второй фазы обработки
    for (int i = 0; i < thread_count; ++i) {
        threads.emplace_back(worker_max, i);
    }

    // Ожидание завершения всех потоков второй фазы
    for (auto& th : threads) {
        th.join();
    }

    // Сборка глобального максимума из частичных максимумов
    double max_salary = 0.0;
    for (int i = 0; i < thread_count; ++i) {
        if (partial_max[i] > max_salary) {
            max_salary = partial_max[i];  // Обновление глобального максимума
        }
    }

    return { avg_age, max_salary };  // Возврат финальных результатов
}